/** ###################################################################
**     THIS BEAN MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
**     Filename  : ADCon.C
**     Project   : CF2_0
**     Processor : MCF52255CAF80
**     Beantype  : ADC
**     Version   : Bean 01.557, Driver 01.03, CPU db: 3.00.000
**     Compiler  : CodeWarrior MCF C Compiler
**     Date/Time : 2012-3-23, 16:50
**     Abstract  :
**         This device "ADC" implements an A/D converter,
**         its control methods and interrupt/event handling procedure.
**     Settings  :
**         AD control register         : CTRL1       [0x00190000]
**         AD control register         : CTRL2       [0x00190002]
**         AD control register         : ADZCC       [0x00190004]
**         AD control register         : ADLST1      [0x00190006]
**         AD control register         : ADLST2      [0x00190008]
**         AD control register         : ADSDIS      [0x0019000A]
**         AD control register         : ADSTAT      [0x0019000C]
**         AD control register         : ADLSTAT     [0x0019000E]
**         AD control register         : ADZCSTAT    [0x00190010]
**         AD control register         : ADLLMT0     [0x00190022]
**         AD control register         : ADLLMT1     [0x00190024]
**         AD control register         : ADLLMT2     [0x00190026]
**         AD control register         : ADLLMT3     [0x00190028]
**         AD control register         : ADLLMT4     [0x0019002A]
**         AD control register         : ADLLMT5     [0x0019002C]
**         AD control register         : ADLLMT6     [0x0019002E]
**         AD control register         : ADLLMT7     [0x00190030]
**         AD control register         : ADHLMT0     [0x00190032]
**         AD control register         : ADHLMT1     [0x00190034]
**         AD control register         : ADHLMT2     [0x00190036]
**         AD control register         : ADHLMT3     [0x00190038]
**         AD control register         : ADHLMT4     [0x0019003A]
**         AD control register         : ADHLMT5     [0x0019003C]
**         AD control register         : ADHLMT6     [0x0019003E]
**         AD control register         : ADHLMT7     [0x00190040]
**         AD control register         : ADOFS0      [0x00190042]
**         AD control register         : ADOFS1      [0x00190044]
**         AD control register         : ADOFS2      [0x00190046]
**         AD control register         : ADOFS3      [0x00190048]
**         AD control register         : ADOFS4      [0x0019004A]
**         AD control register         : ADOFS5      [0x0019004C]
**         AD control register         : ADOFS6      [0x0019004E]
**         AD control register         : ADOFS7      [0x00190050]
**         AD control register         : POWER       [0x00190052]
**         AD control register         : CAL         [0x00190054]
**         Interrupt name              : INT_ADC_ADCA
**         Priority                    : 430
**         User handling procedure     : not specified
**         Number of conversions       : 8
**         AD resolution               : 12-bit
**
**         Input pins
**
**              Port name              : PORTAN
**              Bit number (in port)   : 0
**              Bit mask of the port   : 0x0001
**              Port data register     : PORTAN      [0x0010000A]
**              Port control register  : DDRAN       [0x00100022]
**              Port function register : PANPAR      [0x0010006A]
**
**              Port name              : PORTAN
**              Bit number (in port)   : 1
**              Bit mask of the port   : 0x0002
**              Port data register     : PORTAN      [0x0010000A]
**              Port control register  : DDRAN       [0x00100022]
**              Port function register : PANPAR      [0x0010006A]
**
**              Port name              : PORTAN
**              Bit number (in port)   : 2
**              Bit mask of the port   : 0x0004
**              Port data register     : PORTAN      [0x0010000A]
**              Port control register  : DDRAN       [0x00100022]
**              Port function register : PANPAR      [0x0010006A]
**
**              Port name              : PORTAN
**              Bit number (in port)   : 3
**              Bit mask of the port   : 0x0008
**              Port data register     : PORTAN      [0x0010000A]
**              Port control register  : DDRAN       [0x00100022]
**              Port function register : PANPAR      [0x0010006A]
**
**              Port name              : PORTAN
**              Bit number (in port)   : 4
**              Bit mask of the port   : 0x0010
**              Port data register     : PORTAN      [0x0010000A]
**              Port control register  : DDRAN       [0x00100022]
**              Port function register : PANPAR      [0x0010006A]
**
**              Port name              : PORTAN
**              Bit number (in port)   : 5
**              Bit mask of the port   : 0x0020
**              Port data register     : PORTAN      [0x0010000A]
**              Port control register  : DDRAN       [0x00100022]
**              Port function register : PANPAR      [0x0010006A]
**
**              Port name              : PORTAN
**              Bit number (in port)   : 6
**              Bit mask of the port   : 0x0040
**              Port data register     : PORTAN      [0x0010000A]
**              Port control register  : DDRAN       [0x00100022]
**              Port function register : PANPAR      [0x0010006A]
**
**         Initialization:
**              Conversion             : Enabled
**              Event                  : Enabled
**         High speed mode
**             Prescaler               : divide-by-16
**     Contents  :
**         Measure        - byte ADCon_Measure(bool WaitForResult);
**         MeasureChan    - byte ADCon_MeasureChan(bool WaitForResult, byte Channel);
**         GetValue16     - byte ADCon_GetValue16(word *Values);
**         GetChanValue16 - byte ADCon_GetChanValue16(byte Channel, word *Value);
**
**     Copyright : 1997 - 2009 Freescale Semiconductor, Inc. All Rights Reserved.
**     
**     http      : www.freescale.com
**     mail      : support@freescale.com
** ###################################################################*/

/* MODULE ADCon. */

#include "ADCon.h"

#define IDLE            0              /* IDLE state           */
#define MEASURE         1              /* MESURE state         */
#define CONTINUOUS      2              /* CONTINUOUS state     */
#define SINGLE          3              /* SINGLE state         */

static const byte Table[] = {          /* Table of mask constants */
0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};
static const byte Channels[] = {       /* Number of the channel for each used sample */
0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x06};
static byte OutFlg;                    /* Measurement finish flags */
static byte SumChan;                   /* Number of the measured channels */
/*lint -esym(765,ADCon_ModeFlg) Disable MISRA rule (23) checking for symbols (ADCon_ModeFlg). */
volatile byte ADCon_ModeFlg;           /* Current state of device */
static byte SumCnt;                    /* Number of conversions */
static dword ADCon_SumV[8];            /* Sum of measured values */
static dword ADCon_OutV[8];            /* Sum of measured values */

/*
** ===================================================================
**     Method      :  ClrSumV (bean ADC)
**
**     Description :
**         Clear values for cumulation of measured results.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void ClrSumV(void)
{
  ADCon_SumV[0] = 0;                   /* Set variable for storing measured values to 0 */
  ADCon_SumV[1] = 0;                   /* Set variable for storing measured values to 0 */
  ADCon_SumV[2] = 0;                   /* Set variable for storing measured values to 0 */
  ADCon_SumV[3] = 0;                   /* Set variable for storing measured values to 0 */
  ADCon_SumV[4] = 0;                   /* Set variable for storing measured values to 0 */
  ADCon_SumV[5] = 0;                   /* Set variable for storing measured values to 0 */
  ADCon_SumV[6] = 0;                   /* Set variable for storing measured values to 0 */
  ADCon_SumV[7] = 0;                   /* Set variable for storing measured values to 0 */
}

/*
** ===================================================================
**     Method      :  ADCon_InterruptCC (bean ADC)
**
**     Description :
**         The method services the conversion complete interrupt of the 
**         selected peripheral(s) and eventually invokes the beans 
**         event(s).
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
__declspec(interrupt) void ADCon_InterruptCC(void)
{
  setReg16Bits(ADSTAT,0x0800);         /* Clear EOSI flag */
  if (ADCon_ModeFlg != SINGLE) {
    ADCon_SumV[0] += getReg16(ADRSLT0); /* Save measured values to the output buffer */
    ADCon_SumV[1] += getReg16(ADRSLT1); /* Save measured values to the output buffer */
    ADCon_SumV[2] += getReg16(ADRSLT2); /* Save measured values to the output buffer */
    ADCon_SumV[3] += getReg16(ADRSLT3); /* Save measured values to the output buffer */
    ADCon_SumV[4] += getReg16(ADRSLT4); /* Save measured values to the output buffer */
    ADCon_SumV[5] += getReg16(ADRSLT5); /* Save measured values to the output buffer */
    ADCon_SumV[6] += getReg16(ADRSLT6); /* Save measured values to the output buffer */
    ADCon_SumV[7] += getReg16(ADRSLT7); /* Save measured values to the output buffer */
    SumCnt++;
    if ( SumCnt == 8 ) {
      OutFlg = 0xFF;                   /* Measured values are available */
      ADCon_OutV[0] = ADCon_SumV[0];   /* Save measured values to the output buffer */
      ADCon_OutV[1] = ADCon_SumV[1];   /* Save measured values to the output buffer */
      ADCon_OutV[2] = ADCon_SumV[2];   /* Save measured values to the output buffer */
      ADCon_OutV[3] = ADCon_SumV[3];   /* Save measured values to the output buffer */
      ADCon_OutV[4] = ADCon_SumV[4];   /* Save measured values to the output buffer */
      ADCon_OutV[5] = ADCon_SumV[5];   /* Save measured values to the output buffer */
      ADCon_OutV[6] = ADCon_SumV[6];   /* Save measured values to the output buffer */
      ADCon_OutV[7] = ADCon_SumV[7];   /* Save measured values to the output buffer */
      ADCon_ModeFlg = IDLE;            /* Set the bean to the idle mode */
    }
    else {
      setReg16Bit(CTRL1,START0);       /* Launching of conversion */
    }
  }
  else {
    ADCon_SumV[SumChan] += getReg16(ADRSLT0); /* Save measured values to the output buffer */
    SumCnt++;
    if ( SumCnt == 8 ) {
      OutFlg |= Table[SumChan];        /* Measured values are available */
      ADCon_OutV[SumChan] = ADCon_SumV[SumChan]; /* Save measured values to the output buffer */
      ADCon_ModeFlg = IDLE;            /* Set the bean to the idle mode */
    }
    else {
      setReg16Bit(CTRL1,START0);       /* Launching of conversion */
    }
  }
}

/*
** ===================================================================
**     Method      :  HWEnDi (bean ADC)
**
**     Description :
**         Enables or disables the peripheral(s) associated with the bean.
**         The method is called automatically as a part of Enable, 
**         Disable and Init methods and several internal methods.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void HWEnDi(void)
{
  if (ADCon_ModeFlg) {                 /* Launch measurement? */
    SumCnt = 0;                        /* Clear the number of conversions */
    if (ADCon_ModeFlg != SINGLE) {
      OutFlg = 0x00;                   /* Measured values are available */
      ClrSumV();                       /* Clear measured values */
    }
    else {
      OutFlg &= ~Table[SumChan];       /* Output value isn't available */
      ADCon_SumV[SumChan] = 0;         /* Clear measured value */
    }
    clrReg16Bit(CTRL1,STOP0);          /* Normal operation mode */
    setReg16Bit(CTRL1,START0);         /* Launching of conversion */
  }
  else {
    setReg16Bit(CTRL1,STOP0);          /* Stop command issued */
  }
}

/*
** ===================================================================
**     Method      :  ADCon_Measure (bean ADC)
**
**     Description :
**         This method performs one measurement on all channels that
**         are set in the bean inspector. (Note: If the <number of
**         conversions> is more than one the conversion of A/D channels
**         is performed specified number of times.)
**     Parameters  :
**         NAME            - DESCRIPTION
**         WaitForResult   - Wait for a result of a
**                           conversion. If <interrupt service> is
**                           disabled, A/D peripheral doesn't support
**                           measuring all channels at once or Autoscan
**                           mode property isn't enabled and at the same
**                           time the <number of channel> is greater
**                           than 1, then the WaitForResult parameter is
**                           ignored and the method waits for each
**                           result every time. If the <interrupt
**                           service> is disabled and a <number of
**                           conversions> is greater than 1, the
**                           parameter is ignored and the method also
**                           waits for each result every time.
**     Returns     :
**         ---             - Error code, possible codes:
**                           ERR_OK - OK
**                           ERR_SPEED - This device does not work in
**                           the active speed mode
**                           ERR_DISABLED - Device is disabled
**                           ERR_BUSY - A conversion is already running
** ===================================================================
*/
byte ADCon_Measure(bool WaitForResult)
{
  if (ADCon_ModeFlg != IDLE)           /* Is the device in running mode? */
    return ERR_BUSY;                   /* If yes then error */
  /* ADLST1: ??=0,SAMPLE3=3,??=0,SAMPLE2=2,??=0,SAMPLE1=1,??=0,SAMPLE0=0 */
  setReg16(ADLST1,0x3210);             /* Set ADC channel list reg. */
  /* ADSDIS: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,DS7=0,DS6=0,DS5=0,DS4=0,DS3=0,DS2=0,DS1=0,DS0=0 */
  setReg16(ADSDIS,0x00);               /* Enable/disable of samples */
  ADCon_ModeFlg = MEASURE;             /* Set state of device to the measure mode */
  HWEnDi();                            /* Enable the device */
  if (WaitForResult)                   /* Is WaitForResult TRUE? */
    while (ADCon_ModeFlg == MEASURE) {} /* If yes then wait for end of measurement */
  return ERR_OK;                       /* OK */
}

/*
** ===================================================================
**     Method      :  ADCon_MeasureChan (bean ADC)
**
**     Description :
**         This method performs measurement on one channel. (Note: If
**         the <number of conversions> is more than one the conversion
**         of the A/D channel is performed specified number of times.)
**     Parameters  :
**         NAME            - DESCRIPTION
**         WaitForResult   - Wait for a result of
**                           conversion. If the <interrupt service> is
**                           disabled and at the same time a <number of
**                           conversions> is greater than 1, the
**                           WaitForResult parameter is ignored and the
**                           method waits for each result every time.
**         Channel         - Channel number. If only one
**                           channel in the bean is set this parameter
**                           is ignored, because the parameter is set
**                           inside this method.
**     Returns     :
**         ---             - Error code, possible codes:
**                           ERR_OK - OK
**                           ERR_SPEED - This device does not work in
**                           the active speed mode
**                           ERR_DISABLED - Device is disabled
**                           ERR_BUSY - A conversion is already running
**                           ERR_RANGE - Parameter "Channel" out of range
** ===================================================================
*/
byte ADCon_MeasureChan(bool WaitForResult,byte Channel)
{
  if (Channel >= 8)                    /* Is channel number out of range? */
    return ERR_RANGE;                  /* If yes then error */
  if (ADCon_ModeFlg != IDLE)           /* Is the device in running mode? */
    return ERR_BUSY;                   /* If yes then error */
  setReg16(ADLST1,Channels[Channel]);  /* Set ADC channel list reg. */
  /* ADSDIS: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,DS7=1,DS6=1,DS5=1,DS4=1,DS3=1,DS2=1,DS1=1,DS0=0 */
  setReg16(ADSDIS,0xFE);               /* Enable/disable of sample 0 */
  ADCon_ModeFlg = SINGLE;              /* Set state of device to the measure mode */
  SumChan = Channel;                   /* Set required channel */
  HWEnDi();                            /* Enable the device */
  if (WaitForResult)                   /* Is WaitForResult TRUE? */
    while (ADCon_ModeFlg == SINGLE) {} /* If yes then wait for end of measurement */
  return ERR_OK;                       /* OK */
}

/*
** ===================================================================
**     Method      :  ADCon_GetValue16 (bean ADC)
**
**     Description :
**         This method returns the last measured values of all channels
**         justified to the left. Compared with <GetValue> method this
**         method returns more accurate result if the <number of
**         conversions> is greater than 1 and <AD resolution> is less
**         than 16 bits. In addition, the user code dependency on <AD
**         resolution> is eliminated.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * Values          - Pointer to the array that contains
**                           the measured data.
**     Returns     :
**         ---             - Error code, possible codes:
**                           ERR_OK - OK
**                           ERR_SPEED - This device does not work in
**                           the active speed mode
**                           ERR_NOTAVAIL - Requested value not
**                           available
**                           ERR_OVERRUN - External trigger overrun flag
**                           was detected after the last value(s) was
**                           obtained (for example by GetValue). This
**                           error may not be supported on some CPUs
**                           (see generated code).
** ===================================================================
*/
byte ADCon_GetValue16(word *Values)
{
  if (OutFlg != 0xFF)                  /* Is measured value(s) available? */
    return ERR_NOTAVAIL;               /* If no then error */
  *Values++ = (word)((((word)(ADCon_OutV[0] / 8)) + 0x00) << 1); /* Store value from output to user buffer */
  *Values++ = (word)((((word)(ADCon_OutV[1] / 8)) + 0x00) << 1); /* Store value from output to user buffer */
  *Values++ = (word)((((word)(ADCon_OutV[2] / 8)) + 0x00) << 1); /* Store value from output to user buffer */
  *Values++ = (word)((((word)(ADCon_OutV[3] / 8)) + 0x00) << 1); /* Store value from output to user buffer */
  *Values++ = (word)((((word)(ADCon_OutV[4] / 8)) + 0x00) << 1); /* Store value from output to user buffer */
  *Values++ = (word)((((word)(ADCon_OutV[5] / 8)) + 0x00) << 1); /* Store value from output to user buffer */
  *Values++ = (word)((((word)(ADCon_OutV[6] / 8)) + 0x00) << 1); /* Store value from output to user buffer */
  *Values = (word)((((word)(ADCon_OutV[7] / 8)) + 0x00) << 1); /* Store value from output to user buffer */
  return ERR_OK;                       /* OK */
}

/*
** ===================================================================
**     Method      :  ADCon_GetChanValue16 (bean ADC)
**
**     Description :
**         This method returns the last measured value of the required
**         channel justified to the left. Compared with <GetChanValue>
**         method this method returns more accurate result if the
**         <number of conversions> is greater than 1 and <AD resolution>
**         is less than 16 bits. In addition, the user code dependency
**         on <AD resolution> is eliminated.
**     Parameters  :
**         NAME            - DESCRIPTION
**         Channel         - Channel number. If only one
**                           channel in the bean is set then this
**                           parameter is ignored.
**       * Value           - Pointer to the measured value.
**     Returns     :
**         ---             - Error code, possible codes:
**                           ERR_OK - OK
**                           ERR_SPEED - This device does not work in
**                           the active speed mode
**                           ERR_NOTAVAIL - Requested value not
**                           available
**                           ERR_RANGE - Parameter "Channel" out of
**                           range
**                           ERR_OVERRUN - External trigger overrun flag
**                           was detected after the last value(s) was
**                           obtained (for example by GetValue). This
**                           error may not be supported on some CPUs
**                           (see generated code).
** ===================================================================
*/
byte ADCon_GetChanValue16(byte Channel,word *Value)
{
  if (Channel >= 8)                    /* Is channel number out of range? */
    return ERR_RANGE;                  /* If yes then error */
  if (!(OutFlg & Table[Channel]))      /* Is measured value(s) available? */
    return ERR_NOTAVAIL;               /* If no then error */
  *Value = (word)((((word)(ADCon_OutV[Channel] / 8)) + 0x00) << 1); /* Store value from output to user buffer */
  return ERR_OK;                       /* OK */
}

/*
** ===================================================================
**     Method      :  ADCon_Init (bean ADC)
**
**     Description :
**         Initializes the associated peripheral(s) and the beans 
**         internal variables. The method is called automatically as a 
**         part of the application initialization code.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
void ADCon_Init(void)
{
  volatile word i;

  OutFlg = 0;                          /* No measured value */
  ADCon_ModeFlg = IDLE;                /* Device isn't running */
  /* CTRL1: ??=0,STOP0=1,START0=0,SYNC0=0,EOSIE0=1,ZCIE=0,LLMTIE=0,HLMTIE=0,CHNCFG=0,??=0,SMODE=0 */
  setReg16(CTRL1,0x4800);              /* Set control register 1 */
  /* CAL: SEL_VREFH=0,SEL_VREFL=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0 */
  setReg16(CAL,0x00);                  /* Set calibration register */
  /* POWER: ASB=0,??=0,??=0,PSTS2=0,PSTS1=0,PSTS0=0,PUDELAY=0x0D,APD=0,PD2=0,PD1=0,PD0=0 */
  setReg16(POWER,0xD0);                /* Enable device */
  /* ADOFS0: ??=0,OFFSET=0,??=0,??=0,??=0 */
  setReg16(ADOFS0,0x00);               /* Set offset reg. 0 */
  /* ADOFS1: ??=0,OFFSET=0,??=0,??=0,??=0 */
  setReg16(ADOFS1,0x00);               /* Set offset reg. 1 */
  /* ADOFS2: ??=0,OFFSET=0,??=0,??=0,??=0 */
  setReg16(ADOFS2,0x00);               /* Set offset reg. 2 */
  /* ADOFS3: ??=0,OFFSET=0,??=0,??=0,??=0 */
  setReg16(ADOFS3,0x00);               /* Set offset reg. 3 */
  /* ADOFS4: ??=0,OFFSET=0,??=0,??=0,??=0 */
  setReg16(ADOFS4,0x00);               /* Set offset reg. 4 */
  /* ADOFS5: ??=0,OFFSET=0,??=0,??=0,??=0 */
  setReg16(ADOFS5,0x00);               /* Set offset reg. 5 */
  /* ADOFS6: ??=0,OFFSET=0,??=0,??=0,??=0 */
  setReg16(ADOFS6,0x00);               /* Set offset reg. 6 */
  /* ADOFS7: ??=0,OFFSET=0,??=0,??=0,??=0 */
  setReg16(ADOFS7,0x00);               /* Set offset reg. 7 */
  /* ADHLMT0: ??=0,HLMT=0x0FFF,??=0,??=0,??=0 */
  setReg16(ADHLMT0,0x7FF8);            /* Set high limit reg. 0 */
  /* ADHLMT1: ??=0,HLMT=0x0FFF,??=0,??=0,??=0 */
  setReg16(ADHLMT1,0x7FF8);            /* Set high limit reg. 1 */
  /* ADHLMT2: ??=0,HLMT=0x0FFF,??=0,??=0,??=0 */
  setReg16(ADHLMT2,0x7FF8);            /* Set high limit reg. 2 */
  /* ADHLMT3: ??=0,HLMT=0x0FFF,??=0,??=0,??=0 */
  setReg16(ADHLMT3,0x7FF8);            /* Set high limit reg. 3 */
  /* ADHLMT4: ??=0,HLMT=0x0FFF,??=0,??=0,??=0 */
  setReg16(ADHLMT4,0x7FF8);            /* Set high limit reg. 4 */
  /* ADHLMT5: ??=0,HLMT=0x0FFF,??=0,??=0,??=0 */
  setReg16(ADHLMT5,0x7FF8);            /* Set high limit reg. 5 */
  /* ADHLMT6: ??=0,HLMT=0x0FFF,??=0,??=0,??=0 */
  setReg16(ADHLMT6,0x7FF8);            /* Set high limit reg. 6 */
  /* ADHLMT7: ??=0,HLMT=0x0FFF,??=0,??=0,??=0 */
  setReg16(ADHLMT7,0x7FF8);            /* Set high limit reg. 7 */
  /* ADLLMT0: ??=0,LLMT=0,??=0,??=0,??=0 */
  setReg16(ADLLMT0,0x00);              /* Set low limit reg. 0 */
  /* ADLLMT1: ??=0,LLMT=0,??=0,??=0,??=0 */
  setReg16(ADLLMT1,0x00);              /* Set low limit reg. 1 */
  /* ADLLMT2: ??=0,LLMT=0,??=0,??=0,??=0 */
  setReg16(ADLLMT2,0x00);              /* Set low limit reg. 2 */
  /* ADLLMT3: ??=0,LLMT=0,??=0,??=0,??=0 */
  setReg16(ADLLMT3,0x00);              /* Set low limit reg. 3 */
  /* ADLLMT4: ??=0,LLMT=0,??=0,??=0,??=0 */
  setReg16(ADLLMT4,0x00);              /* Set low limit reg. 4 */
  /* ADLLMT5: ??=0,LLMT=0,??=0,??=0,??=0 */
  setReg16(ADLLMT5,0x00);              /* Set low limit reg. 5 */
  /* ADLLMT6: ??=0,LLMT=0,??=0,??=0,??=0 */
  setReg16(ADLLMT6,0x00);              /* Set low limit reg. 6 */
  /* ADLLMT7: ??=0,LLMT=0,??=0,??=0,??=0 */
  setReg16(ADLLMT7,0x00);              /* Set low limit reg. 7 */
  /* ADZCSTAT: ??=1,??=1,??=1,??=1,??=1,??=1,??=1,??=1,ZCS7=1,ZCS6=1,ZCS5=1,ZCS4=1,ZCS3=1,ZCS2=1,ZCS1=1,ZCS0=1 */
  setReg16(ADZCSTAT,0xFFFF);           /* Clear zero crossing status flags */
  /* ADLSTAT: HLS7=1,HLS6=1,HLS5=1,HLS4=1,HLS3=1,HLS2=1,HLS1=1,HLS0=1,LLS7=1,LLS6=1,LLS5=1,LLS4=1,LLS3=1,LLS2=1,LLS1=1,LLS0=1 */
  setReg16(ADLSTAT,0xFFFF);            /* Clear high and low limit status */
  /* ADSTAT: CIP0=0,CIP1=0,??=0,EOSI1=0,EOSI0=1,ZCI=0,LLMTI=0,HLMTI=0,RDY7=0,RDY6=0,RDY5=0,RDY4=0,RDY3=0,RDY2=0,RDY1=0,RDY0=0 */
  setReg16(ADSTAT,0x0800);             /* Clear EOSI flag */
  /* ADLST2: ??=0,SAMPLE7=6,??=0,SAMPLE6=6,??=0,SAMPLE5=5,??=0,SAMPLE4=4 */
  setReg16(ADLST2,0x6654);             /* Set ADC channel list reg. */
  /* ADZCC: ZCE7=0,ZCE6=0,ZCE5=0,ZCE4=0,ZCE3=0,ZCE2=0,ZCE1=0,ZCE0=0 */
  setReg16(ADZCC,0x00);                /* Set zero crossing control reg. */
  /* CTRL2: ??=0,STOP1=0,START1=0,SYNC1=0,EOSIE1=0,??=0,??=0,??=0,??=0,??=0,SIMULT=1,DIV=7 */
  setReg16(CTRL2,0x27);                /* Set prescaler */
  for (i=0;i<0x64;i++) {}              /* Recovery time of voltage reference */
  while (POWER&((POWER_PSTS0_BITMASK|POWER_PSTS1_BITMASK|POWER_PSTS2_BITMASK))) {} /* Wait for device powered up */
}



/* END ADCon. */

/*
** ###################################################################
**
**     This file was created by Processor Expert 1.05 [04.27]
**     for the Freescale MCF series of microcontrollers.
**
** ###################################################################
*/
